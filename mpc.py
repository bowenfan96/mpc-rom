# Import Pyomo classes
from pyomo.environ import *
from pyomo.dae import *
from pyomo.solvers import *

# Import system file with real dynamics
import system

from matplotlib import pyplot as plt
import numpy as np
import pandas as pd

import datetime

matrices_folder = "matrices/heateqn/"
results_folder = "results_csv/"
plots_folder = "results_plots/"


class MPC:
    def __init__(self, xi_csv, a_csv, b_csv, duration, ncp, gen_data=True):
        """
        x_dot = Ax + Bu
        :param xi_csv: Initial system state
        :param a_csv: Matrix A as a csv file
        :param b_csv: Matrix B as a csv file
        :param duration: Number of time steps
        """

        self.xi_csv = xi_csv
        self.a_csv = a_csv
        self.b_csv = b_csv
        self.duration = duration
        self.ncp = ncp

        self.A = np.genfromtxt(a_csv, delimiter=',')
        self.B = np.genfromtxt(b_csv, delimiter=',')
        # A should be a square matrix
        assert self.A.ndim == 2 and self.A.shape[0] == self.A.shape[1]
        # A and B should have same number of rows
        assert self.B.shape[0] == self.A.shape[0]

        # If we are generating data to train the model reduction neural net,
        # then initial x_i is randomly generated
        if gen_data:
            self.x = np.random.randint(low=-10000, high=10000, size=self.A.shape[0])
        else:
            self.x = np.genfromtxt(xi_csv, delimiter=',')
        assert self.x.ndim == 1
        assert self.x.shape[0] == self.A.shape[0]

        # Add a timestamp for labelling autogenerated files
        now = datetime.datetime.now()
        self.runtime = str(now.day) + str(now.hour) + str(now.minute) + str(now.second)

        # ----- BEGIN PYOMO CODE ----- #
        # Initialize pyomo model
        self.model = ConcreteModel()

        # Force the discretizer subsequently to include every timestep in our duration
        self.timesteps = range(0, self.duration, 1)
        self.model.time = ContinuousSet(
            bounds=(0, self.duration), initialize=self.timesteps)

        self.model.I = RangeSet(0, self.A.shape[1]-1)
        self.model.J = RangeSet(0, self.B.shape[1]-1)
        self.model.x = Var(self.model.I, self.model.time, initialize=0)
        self.model.x_dot = DerivativeVar(self.model.x, wrt=self.model.time, initialize=0)

        self.model.u = Var(self.model.J, self.model.time, initialize=0)

        # Edit finite element step size here
        self.discretizer = TransformationFactory('dae.collocation')
        self.discretizer.apply_to(self.model, wrt=self.model.time, nfe=self.duration,
                                  scheme='LAGRANGE-RADAU', ncp=self.ncp)

        # Define derivative variables
        def ode_Ax(m, i, t):
            return sum((m.x[j, t] * self.A[i][j]) for j in range(self.A.shape[1]))

        def ode_Bu(m, i, t):
            return sum((m.u[j, t] * self.B[i][j]) for j in range(self.B.shape[1]))

        self.model.ode = ConstraintList()

        for time in self.model.time:
            for i in range(self.A.shape[0]):
                self.model.ode.add(
                    self.model.x_dot[i, time] == ode_Ax(self.model, i, time) + ode_Bu(self.model, i, time)
                )
                # Fix variables based on initial values
                self.model.x[i, 0].fix(self.x[i])

        # Objective: Bring the entire system to zero AND minimize controller cost
        def obj_rule(m):
            setpoint_cost = sum(abs(m.x[i]) for i in m.I * m.time)
            controller_cost = sum(abs(m.u[j]) for j in m.J * m.time)
            # Edit weights for setpoint and controller costs
            weighted_cost = 0.5*setpoint_cost + 0.5*controller_cost
            return weighted_cost

        self.model.obj = Objective(
            rule=obj_rule,
            sense=minimize
        )

    def calc_ctg(self, x, u):
        """
        Calculate the cost to go given system and controller states
        :param x: System (x) states given as an array
        :param u: Controller (u) states given as an array
        :return: Append cost to go to system and controller states and return x_u_ctg
        """
        # ----- EDIT COST FUNCTION BELOW ----- #
        def cost(x_row, u_row):
            setpoint_cost = sum(abs(xi) for xi in x_row)
            controller_cost = sum(abs(ui) for ui in u_row)
            weighted_cost = 0.5*setpoint_cost + 0.5*controller_cost
            return weighted_cost
        # ----- EDIT COST FUNCTION ABOVE ----- #

        # If duration is 100, there should be 101 entries as initial x0 and u0 are included
        assert x.shape[0] == self.duration + 1
        assert u.shape[0] == self.duration + 1

        cost_to_go = []
        for t in range(self.duration+1):
            cost_to_go.append(cost(x[t], u[t]))
        for t in reversed(range(self.duration)):
            cost_to_go[t] += cost_to_go[t+1]

        cost_to_go = np.array(cost_to_go).reshape(-1, 1)
        return cost_to_go

    def solve(self, sim_sys=True):
        """
        Solve the system to derive the set of optimal controls at each time step
        :param sim_sys: If simulating a system, we calculate the control action at every timestep,
        apply the action to the system simulation, then fix the mpc state to the actual state returned
        by the system simulation
        :return: MPC state variables (mpc_x), MPC control actions (u), Cost to go,
        Simulated system state variables (sys_x) if simulating the system
        """
        opt = SolverFactory('ipopt', tee=True)
        opt.options['max_iter'] = 10000
        results = None

        mpc_state = []
        sys_state = []
        mpc_action = []

        if sim_sys:
            # Create a system object to simulate taking readings from an actual system
            sys = system.System(self.xi_csv, self.a_csv, self.b_csv)

            for time in self.model.time:
                # MPC solver
                print("Solving...")

                results = opt.solve(self.model)
                mpc_state.append(list(value(self.model.x[:, time])))

                # Send these controls to system
                controls = list(value(self.model.u[:, time]))

                mpc_action.append(controls)

                self.x = np.array(sys.simulate(duration=1, controls=controls))
                self.x = self.x.flatten()

                # self.model.display()
                print(self.x)
                sys_state.append(self.x)

                for i in self.model.I:
                    print("Time: {}, x_{}: {}".format(time, i, self.x[i]))
                    self.model.x[i, time].fix(self.x[i])

        else:
            results = opt.solve(self.model)
            self.model.display()

            # Record values at intervals of 1 timestep
            # Necessary as discretizer is more granular than our step size
            for time in self.model.time:
                if float(time).is_integer():
                    mpc_state.append(list(value(self.model.x[:, time])))
                    mpc_action.append(list(value(self.model.u[:, time])))

        # Output error if solution cannot be found, otherwise solver should print "ok"
        print(results.solver.status)

        # Turn lists into numpy arrays
        mpc_state = np.array(mpc_state)
        mpc_action = np.array(mpc_action)
        sys_state = np.array(sys_state)

        cost_to_go = self.calc_ctg(mpc_state, mpc_action)

        if sim_sys:
            return mpc_state, sys_state, mpc_action, cost_to_go
        else:
            return mpc_state, mpc_action, cost_to_go

    def plot(self, mpc_state=None, sys_state=None, mpc_action=None, ctg=None):
        """
        Plot a nice graph
        :param mpc_state: mpc_x
        :param sys_state: sys_x
        :param mpc_action: u
        :param ctg: cost to go
        :return: Save a nice graph
        """
        # To fix empty subplot blank space problem
        if sys_state is not None:
            fig, axs = plt.subplots(4)
        else:
            fig, axs = plt.subplots(3)

        # Make figure the size of an A4 page
        fig.set_size_inches(8.3, 11.7)

        # Note the order of the plots, to avoid the blank sys plot
        if mpc_state is not None:
            for i in range(len(mpc_state[0])):
                axs[0].plot(mpc_state[:, i], label='mpc_x_{}'.format(i))
            axs[0].legend(loc='upper right', fontsize='small')
            axs[0].set_title("MPC state variables (x) against time", fontsize='medium')

        if sys_state is not None:
            for i in range(len(sys_state[0])):
                axs[3].plot(sys_state[:, i], label='sys_x_{}'.format(i))
            axs[3].legend(loc='upper right', fontsize='small')
            axs[0].set_title("System state variables (x) against time", fontsize='medium')

        if mpc_action is not None:
            for j in range(len(mpc_action[0])):
                axs[1].plot(mpc_action[:, j], label='u_{}'.format(j))
            axs[1].legend(loc='upper right', fontsize='small')
            axs[1].set_title("MPC control action (u) against time", fontsize='medium')

        if ctg is not None:
            axs[2].plot(ctg, label='ctg')
            axs[2].legend(loc='upper right', fontsize='small')
            axs[2].set_title("Cost to go against time", fontsize='medium')

        plt.xlabel("Time")
        # Tick at every 5 integer timesteps
        plt.xticks(range(0, self.duration+1, 5))
        plt.savefig(plots_folder + "mpc_plot" + self.runtime + ".svg", format="svg")
        plt.show()

    def save_results(self, mpc_state=None, sys_state=None, mpc_action=None, ctg=None):
        df_col_names = []
        data_export = None

        if mpc_state is not None:
            df_col_names.extend("mpc_x_{}".format(i) for i in range(self.A.shape[1]))
            data_export = mpc_state
        if sys_state is not None:
            df_col_names.extend("sys_x_{}".format(i) for i in range(self.A.shape[1]))
            data_export = np.hstack((data_export, sys_state))
        if mpc_action is not None:
            df_col_names.extend("u_{}".format(i) for i in range(self.B.shape[1]))
            data_export = np.hstack((data_export, mpc_action))
        if ctg is not None:
            df_col_names.extend(["ctg"])
            data_export = np.hstack((data_export, ctg))

        df_mpc_x_u_ctg = pd.DataFrame(data_export, columns=df_col_names)
        df_mpc_x_u_ctg.to_csv(results_folder + "mpc_x_u_ctg" + self.runtime + ".csv")


if __name__ == "__main__":
    mpc = MPC(matrices_folder + "xi.csv",
              matrices_folder + "A.csv",
              matrices_folder + "B.csv",
              duration=50, ncp=3)

    mpc_x, u, v = mpc.solve(sim_sys=False)
    mpc.plot(mpc_state=mpc_x, mpc_action=u, ctg=v)
    mpc.save_results(mpc_state=mpc_x, mpc_action=u, ctg=v)
