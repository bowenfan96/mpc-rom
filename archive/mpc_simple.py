# SIMPLE MODEL ADAPTED FROM ANTONIO AND PANOS FOR TESTING
# FROM https://colab.research.google.com/drive/17KJn7tVyQ3nXlGSGEJ0z6DcpRnRd0VRp

# Import Pyomo classes
# import pyomo.environ
from pyomo.environ import *
from pyomo.dae import *

# Import system file with real dynamics
import system

from matplotlib import pyplot as plt
import numpy as np
import pandas as pd

import datetime
from time import *

matrices_folder = "C:/Users/FanBo/PycharmProjects/mpc-rom/matrices/simple/"
results_folder = "results_csv/simple/"
plots_folder = "results_plots/simple/"


class MPC:
    def __init__(self, xi_csv, a_csv, b_csv, duration, ncp, gen_data=False, c_csv=None, d_csv=None):
        """
        x_dot = Ax + Bu
        :param xi_csv: Initial system state
        :param a_csv: Matrix A as a csv file
        :param b_csv: Matrix B as a csv file
        :param duration: Number of time steps
        """

        # Don't think these self._csv are ever used, can probably delete
        self.xi_csv = xi_csv
        self.a_csv = a_csv
        self.b_csv = b_csv
        self.c_csv = c_csv if c_csv is not None else None
        self.d_csv = d_csv if d_csv is not None else None

        self.duration = duration
        self.ncp = ncp

        self.A = np.genfromtxt(a_csv, delimiter=',')
        self.B = np.genfromtxt(b_csv, delimiter=',')
        self.C = np.genfromtxt(c_csv, delimiter=',') if c_csv is not None else None
        self.D = np.genfromtxt(d_csv, delimiter=',') if d_csv is not None else None

        # ----- SOME CHECKS TO ENSURE THE INPUT MATRICES ARE FORMATTED CORRECTLY ----- #
        # A should be a square matrix
        assert self.A.ndim == 2 and self.A.shape[0] == self.A.shape[1]
        # A and B should have same number of rows
        assert self.B.shape[0] == self.A.shape[0]

        if self.C is not None:
            # Same number of outputs as the number of rows of C
            # assert self.C.ndim == 2 and self.x.shape[0] == self.C.shape[1]
            self.y = np.zeros(self.C.shape[0])

        if self.D is not None:
            # assert self.D.ndim == 2 and self.x.shape[0] == self.D.shape[0]
            assert self.B.shape[1] == self.D.shape[1]

        # Get number of state variables - dimensionality of x_full - number of rows = columns of A
        self.num_states = self.A.shape[0]
        # Get number of controllers - dimensionality of u_full - number of columns of B
        if self.B.ndim == 1:
            self.num_controllers = 1
        else:
            self.num_controllers = self.B.shape[1]

        # If we are generating data to train the model reduction neural unet,
        # then initial x_i is randomly generated
        if gen_data:
            self.x = np.random.randint(low=-10, high=10, size=self.A.shape[0])
        else:
            self.x = np.genfromtxt(xi_csv, delimiter=',')
        assert self.x.ndim == 1
        assert self.x.shape[0] == self.A.shape[0]

        # Add a timestamp for labelling autogenerated files
        now = datetime.datetime.now()
        self.runtime = str(now.day) + str(now.hour) + str(now.minute) + str(now.second) + str(now.microsecond)

        # E MATRIX FOR CHAHLAOUI MODELS INCLUDING HEAT EQUATION
        # self.E = np.genfromtxt(matrices_folder + "E.csv", delimiter=',')

        # ----- BEGIN PYOMO CODE ----- #
        # Initialize pyomo model
        self.model = ConcreteModel()

        # Force the discretizer subsequently to include every timestep in our duration
        self.timesteps = range(0, self.duration, 1)
        self.model.time = ContinuousSet(
            bounds=(0, self.duration))

        # Pyomo RangeSet includes both first and last
        # Pyomo defaults sets to 1-indexing so we force 0-indexing
        self.model.I = RangeSet(0, self.A.shape[1]-1)
        self.model.x = Var(self.model.I, self.model.time)
        self.model.x_dot = DerivativeVar(self.model.x, wrt=self.model.time, initialize=0)

        # J is turned off if only 1 controller
        assert self.num_controllers >= 1
        if self.num_controllers > 1:
            self.model.J = RangeSet(0, self.B.shape[1]-1)
            self.model.u = Var(self.model.J, self.model.time, initialize=0)
        else:
            self.model.u = Var(self.model.time, initialize=0)

        # Define derivative variables
        def ode_Ax(m, i, t):
            # print(i)
            # sleep(1)
            # print(sum((m.x[j, t] * self.A[i][j]) for j in range(self.A.shape[1])))
            # sleep(1)
            return sum((m.x[j, t] * self.A[i][j]) for j in range(self.A.shape[1]))

        # WHEN WE HAVE MORE THAN 1 CONTROLLER
        if self.num_controllers > 1:
            def ode_Bu(m, i, t):
                return sum((m.u[j, t] * self.B[i][j]) for j in range(self.B.shape[1]))
        else:
            # WHEN WE HAVE 1 CONTROLLER ONLY
            def ode_Bu(m, i, t):
                return m.u[t] * self.B[i]

        self.model.ode = ConstraintList()

        self.model.L = Var(self.model.time)
        self.model.dLdt = DerivativeVar(self.model.L, wrt=self.model.time)

        # Edit finite element step size here
        self.discretizer = TransformationFactory('dae.collocation')
        self.discretizer.apply_to(self.model, wrt=self.model.time, nfe=self.duration*10,
                                  scheme='LAGRANGE-RADAU', ncp=self.ncp)

        # FOR GENERAL X_DOT = AX + BU
        for time in self.model.time:
            for i in range(self.num_states):
                self.model.ode.add(
                    self.model.x_dot[i, time] == ode_Ax(self.model, i, time) + ode_Bu(self.model, i, time)
                )
                # Fix variables based on initial values
                self.model.x[i, 0].fix(self.x[i])
        # Force u to be piecewise linear
        self.discretizer.reduce_collocation_points(self.model, var=self.model.u, ncp=1, contset=self.model.time)

        # define path constraint
        def path_con_rule(m, t):
            return m.x[1, t] + 0.5 - 8 * (t - 0.5) ** 2 <= 0

        self.model.path_con = Constraint(self.model.time, rule=path_con_rule)

        # Lagrange term
        def Ldiffeq_rule(m, t):
            return m.dLdt[t] == m.x[0, t] ** 2 + m.x[1, t] ** 2 + 5 * 10 ** (-3) * m.u[t] ** 2

        self.model.Ldiffeq = Constraint(self.model.time, rule=Ldiffeq_rule)
        self.model.L[0].fix(0)

        # define objective function

        def objective_rule(m):
            return m.L[self.duration] - m.L[0]

        self.model.objective = Objective(rule=objective_rule, sense=minimize)

    def solve(self, sim_sys=True):
        """
        Solve the system to derive the set of optimal controls at each time step
        :param sim_sys: If simulating a system, we calculate the control action at every timestep,
        apply the action to the system simulation, then fix the mpc state to the actual state returned
        by the system simulation
        :return: MPC state variables (mpc_x), MPC control actions (u), Cost to go,
        Simulated system state variables (sys_x) if simulating the system
        """
        opt = SolverFactory('ipopt', tee=True)
        # https://coin-or.github.io/Ipopt/OPTIONS.html
        # opt.options['max_iter'] = 10000
        # opt.options['print_level'] = 12

        # opt = SolverFactory("gurobi", solver_io="python")

        results = None

        mpc_state = []
        sys_state = []
        mpc_action = []
        output = []

        if sim_sys:
            # Create a system object to simulate taking readings from an actual system
            sys = system.System(self.xi_csv, self.a_csv, self.b_csv)

            for time in self.model.time:
                # MPC solver
                print("Solving...")

                results = opt.solve(self.model)
                mpc_state.append(list(value(self.model.x[:, time])))

                # Send these controls to system
                controls = list(value(self.model.u[:, time]))

                mpc_action.append(controls)

                self.x = np.array(sys.simulate(duration=1, controls=controls))
                self.x = self.x.flatten()

                # self.model.display()
                print(self.x)
                sys_state.append(self.x)

                for i in self.model.I:
                    print("Time: {}, x_{}: {}".format(time, i, self.x[i]))
                    self.model.x[i, time].fix(self.x[i])

        else:
            results = opt.solve(self.model)
            self.model.display()

            # Record values at intervals of 1 timestep
            # Necessary as discretizer is more granular than our step size
            for time in self.model.time:
                # if float(time).is_integer():
                    mpc_state.append(list(value(self.model.x[:, time])))
                    if self.num_controllers > 1:
                        mpc_action.append(list(value(self.model.u[:, time])))
                    else:
                        mpc_action.append(value(self.model.u[time]))

        # Output error if solution cannot be found, otherwise solver should print "ok"
        print(results.solver.status)

        # Turn lists into numpy arrays
        mpc_state = np.array(mpc_state)
        mpc_action = np.array(mpc_action)
        sys_state = np.array(sys_state)
        output = np.array(output)

        cost_to_go = self.calc_ctg(mpc_state, mpc_action)

        if sim_sys:
            return mpc_state, sys_state, mpc_action, cost_to_go
        else:
            return mpc_state, mpc_action, cost_to_go

    def calc_ctg(self, x, u, y=None):
        """
        Calculate the cost to go given system and controller states
        :param y: Output (y) if cost depends on y
        :param x: System (x) states given as an array
        :param u: Controller (u) states given as an array
        :return: Append cost to go to system and controller states and return x_u_ctg
        """
        # ----- EDIT COST FUNCTION BELOW ----- #
        def cost(x_row, u_row, time):
            setpoint_cost = x_row[0]**2 + x_row[1]**2
            # setpoint_cost = sum((50 - xi)**2 for xi in x_row)
            # controller_cost = sum(ui**2 for ui in u_row)
            controller_cost = 5E-3 * u_row ** 2
            # weighted_cost = 0.8*setpoint_cost + 0.2*controller_cost
            # return weighted_cost
            return setpoint_cost
        # ----- EDIT COST FUNCTION ABOVE ----- #

        # If duration is 100, there should be 101 entries as initial x0 and u0 are included
        # TURN OFF TO RECORD COLLOCATION POINTS AS DATA
        # assert x.shape[0] == self.duration + 1
        # assert u.shape[0] == self.duration + 1
        if y is not None:
            assert y.shape[0] == self.duration + 1

        cost_to_go = []
        for t in range(self.duration + 1):
            cost_to_go.append(cost(x[t], u[t], t))
        for t in reversed(range(self.duration)):
            cost_to_go[t] += cost_to_go[t+1]

        cost_to_go = np.array(cost_to_go).reshape(-1, 1)
        return cost_to_go

    def plot(self, mpc_state=None, sys_state=None, mpc_action=None, ctg=None, output=None):
        """
        Plot a nice graph
        :param output: y
        :param mpc_state: mpc_x
        :param sys_state: sys_x
        :param mpc_action: u
        :param ctg: cost to go
        :return: Save a nice graph
        """
        print("PLOTTER CALLED")
        if sys_state is not None:
            fig, axs = plt.subplots(5)
        elif output is not None:
            fig, axs = plt.subplots(4)
        else:
            fig, axs = plt.subplots(3)

        # Make figure the size of an A4 page
        fig.set_size_inches(8.3, 11.7)

        # Reshape controller and output into 2d column vector
        if self.num_controllers == 1:
            mpc_action = mpc_action.reshape(-1, 1)

        if mpc_state is not None:
            for i in range(self.num_states):
                # Turn on labelling
                # axs[0].plot(mpc_state[:, i], label='mpc_x_{}'.format(i))
                # axs[0].legend(loc='upper right', fontsize='small')
                # Turn off labelling
                axs[0].plot(mpc_state[:, i])
            axs[0].set_title("MPC state variables (x) against time", fontsize='medium')

        if sys_state is not None:
            for i in range(self.num_states):
                axs[4].plot(sys_state[:, i], label='sys_x_{}'.format(i))
            axs[4].legend(loc='upper right', fontsize='small')
            axs[4].set_title("System state variables (x) against time", fontsize='medium')

        if mpc_action is not None:
            for j in range(self.num_controllers):
                axs[1].plot(mpc_action[:, j], label='u_{}'.format(j), drawstyle='steps-pre')
            axs[1].legend(loc='upper right', fontsize='small')
            axs[1].set_title("MPC control action (u) against time", fontsize='medium')

        if ctg is not None:
            axs[2].plot(ctg, label='ctg')
            axs[2].legend(loc='upper right', fontsize='small')
            axs[2].set_title("Cost to go against time", fontsize='medium')

        if output is not None:
            for k in range(self.num_output):
                axs[2].plot(output[:, k], label='y_{}'.format(k))
            axs[2].legend(loc='upper right', fontsize='small')
            axs[2].set_title("Output (y) against time", fontsize='medium')

        plt.xlabel("Time")
        # Tick at every 5 integer timesteps
        plt.xticks(range(0, self.duration+1, 5))
        # plt.savefig(plots_folder + "mpc_plot" + self.runtime + ".svg", format="svg")
        plt.show()

    def save_results(self, mpc_state=None, sys_state=None, mpc_action=None, ctg=None, output=None):
        df_col_names = []
        data_export = None

        if mpc_state is not None:
            # Reshape controller and output into 2d column vector
            if self.num_controllers == 1:
                mpc_action = mpc_action.reshape(-1, 1)
            df_col_names.extend("mpc_x_{}".format(i) for i in range(self.num_states))
            data_export = mpc_state
        if sys_state is not None:
            df_col_names.extend("sys_x_{}".format(i) for i in range(self.num_states))
            data_export = np.hstack((data_export, sys_state))
        if mpc_action is not None:
            df_col_names.extend("u_{}".format(i) for i in range(self.num_controllers))
            data_export = np.hstack((data_export, mpc_action))
        if output is not None:
            # Reshape controller and output into 2d column vector
            if self.num_output == 1:
                output = output.reshape(-1, 1)
            df_col_names.extend("y_{}".format(i) for i in range(self.num_output))
            data_export = np.hstack((data_export, output))
        if ctg is not None:
            df_col_names.extend(["ctg"])
            data_export = np.hstack((data_export, ctg))

        df_mpc_x_u_ctg = pd.DataFrame(data_export, columns=df_col_names)
        df_mpc_x_u_ctg.to_csv(results_folder + "mpc_x_u_ctg" + self.runtime + ".csv")


if __name__ == "__main__":
    for i in range(1):
        mpc = MPC(xi_csv=matrices_folder + "xi.csv",
                  a_csv=matrices_folder + "A.csv",
                  b_csv=matrices_folder + "B.csv",
                  duration=1, ncp=10,
                  )

        mpc_x, mpc_u, mpc_v = mpc.solve(sim_sys=False)
        mpc.plot(mpc_state=mpc_x, mpc_action=mpc_u, ctg=mpc_v)
        # mpc.save_results(mpc_state=mpc_x, mpc_action=mpc_u, ctg=mpc_v)
